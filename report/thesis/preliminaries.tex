\chapter{Preliminaries}
\section{Abstract DPLL}
In propositional logic, we have a set of \emph{propositional symbols} $P$ and every $p \in P$ is called an \emph{atom}. A \emph{literal} $l$ is either $p$ or $\neg p$ with $p \in P$. The \emph{negation} $\neg l$ of a literal $l$ is $\neg p$ if $l$ is $p$, or $p$ if $l$ is $\neg p$. A disjunction $l_1 \vee \cdots \vee l_n$ of literals is said to be a \emph{clause}. A \emph{Conjuctive Normal Form (CNF) formula} is a conjunction of clauses $C_1 \wedge \cdots \wedge C_n$. If $C = l_1 \vee \cdots \vee l_n$ is a clause, $\neg C$ is used to denote the CNF formula $\neg l_1 \wedge \cdots \wedge \neg l_n$

An (partial) \emph{assignment} $M$ is a set of literals such that $l \in M$ and $\neg l \in M$ for no literal $l$. A literal $l$ is undefined in $M$ if neither $l \in M$ nor $\neg l \in M$. If $l \in M$, $l$ is said to be true in M. On the other hand if $\neg l \in M$, we say that $l$ is false in $M$. A clause is true in $M$ if at least one of its literals is in $M$. An assignment $M$ satisfies a CNF formula $F$ (or $F$ is satisfied by $M$) if all clauses of $F$ is true in $M$ which is denoted as $M \models F$. Given two CNF formula $F$ and $F'$, we write $F \models F'$ if for any assignment $M$, $M \models F$ implies $M \models F'$. The formula $F$ is unsatisfiable if there is no assignment $M$ such that $M \models F$.

Abstract Davis–Putnam–Logemann–Loveland (DPLL) Procedure \cite{Nieuwenhuis05abstractdpll} searches for an assignment that satisfies a CNF formula. Each state of the procedure is either \emph{FailState} or a pair $M \parallel  F$ of an assignment $M$ and a CNF formula $F$. For the purpose of the procedure, $M$ is represented as a sequence of literals where each literal is optionally attached an \emph{annotation}, e.g. $l^d$ which basically means that the literal $l$ is selected to be included in the assignment by making a decision ($l$ is called a decision literal). An empty sequence is denoted by $\emptyset$. Each DPLL procedure is modeled by a collection of states and a binary relation $\Longrightarrow$ between states. Basic DPLL procedure is a transition system which contains the following four rules.
\begin{enumerate}
\item $\mathbf{UnitPropagate}$

$M \parallel F \wedge (C \vee l) \Longrightarrow Ml \parallel F \wedge (C \vee l)$ if $\left\{ 
  \begin{array}{l}
    M \models \neg C \\
    l\text{ is undefined in }M.
  \end{array} \right.$
  
\item $\mathbf{Decide}$

$M \parallel F \Longrightarrow Ml^d \parallel F$ if $\left\{ 
  \begin{array}{l}
    l \text{ or } \neg l \text{ occur in a clause of F} \\
    l\text{ is undefined in }M.
  \end{array} \right.$

\item $\mathbf{Fail}$

$M \parallel F \wedge C \Longrightarrow FailState$ if $\left\{ 
  \begin{array}{l}
    M \models \neg C \\
    l^d \in M \text{ for no literal }l.
  \end{array} \right.$  
  
\item $\mathbf{Backjump}$

$Ml^dM' \parallel F \wedge C \Longrightarrow Ml' \parallel F \wedge C$ if $\left\{ 
  \begin{array}{l}
    Ml^dM' \models \neg C,\text{ and there is some clause } C' \vee l'\\ 
    \text{such that }
    F \wedge C \models C' \vee l'
    \text{ and }M \models \neg C', l' \text{ is }\\
    \text{undefined in } M, \text{ and } l' \text{ or } \neg l' \text{ occurs in } F \text{ or in } \\Ml^dM'.
  \end{array} \right.$  
\end{enumerate}

Let $F$ be a given CNF formula. Starting with the state $\emptyset \parallel F$, basic DPLL procedure terminates with either $FailState$ when $F$ is unsatisfiable, or a state $M \parallel F$ where $M$ satisfies $F$. Intuitively, the above four rules can be explained as following.

\begin{itemize}
\item $\mathbf{UnitPropagate}$: In order to satisfy $F \wedge (C \vee l)$, $C \vee l$ needs to be satisfied. Because all the literals in $C$ is false in current assignment $M$ ($M \models \neg C$), $l$ must be made true when extending $M$.
\item $\mathbf{Decide}$: This rule is applied when no more $\mathbf{UnitPropagation}$ can be applied. The annotation $d$ in $l^d$ denotes that if $Ml$ cannot be extended to satisfy $f$, $M\neg l$ needs to be explored further.
\item $\mathbf{Fail}$: When a clause is false in $M$ (conflict) and $M$ has no literal which is decided by making a decision (there is no more options to explored), the formula $F$ is unsatisfiable.
\item $\mathbf{Backjump}$: As same as in $\mathbf{Fail}$ rule, a conflict is detected. However, in $\mathbf{Backjump}$, because there exists some decision literal in the assignment, new possible assignments can be explored. The clause $C' \vee l'$ is called the backjump clause.
\end{itemize}

\begin{example}
For the formula $(\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2)$, the basic DPLL procedure proceeds as following:

\begin{align*}
\emptyset &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{Decide}) \\
\l_1^d &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{UnitPropagate}) \\
\l_1^dl_2 &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{Decide}) \\
\l_1^dl_2l_3^d &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{UnitPropagate}) \\
\l_1^dl_2l_3^dl_4 &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{Decide})\\
\l_1^dl_2l_3^dl_4l_5^d &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{UnitPropagate})\\
\l_1^dl_2l_3^dl_4l_5^dl_6 &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2) \Longrightarrow (\mathbf{Backjump})\\
\l_1^dl_2l_3^dl_4\neg l_5 &\parallel (\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6) \wedge (l_6 \vee \neg l_5 \vee \neg l_2)
\end{align*}
\sloppy
In the $\mathbf{Bacjump}$ step of this example: $M$ is $l_1^dl_2l_3^dl_4$, $l^d$ is $l_5^d$, 
$M'$ is $l_6$,
$F$ is ${(\neg l_1 \vee l_2) \wedge (\neg l_3 \vee l_4) \wedge (\neg l_5 \vee \neg l_6)}$,
$C$ is $l_6 \vee \neg l_5 \vee \neg l_2$,
$C'$ is $\neg l_1$, and $l'$ is $\neg l_5$.
\end{example}

Additionally DPLL implementation can add the backjump clauses into the CNF formula as learnt clause (or lemmas), which is usually referred as \emph{conflict-driven learning}. Lemmas aim at preventing similar conflicts to occur in the future. When the conflicts are not likely to happen, the lemmas can be removed. The following two rules are prepared for DPLL.

\begin{enumerate}
\setcounter{enumi}{5}
\item $\mathbf{Learn}$

$M \parallel F \Longrightarrow M \parallel F \wedge C$ if $\left\{ 
  \begin{array}{l}
    \text{each atom in C appears in F} \\
    F \models C.
  \end{array} \right.$ 
  
\item $\mathbf{Forget}$

$M \parallel F \wedge C \Longrightarrow M \parallel F$ if $\left\{ 
  \begin{array}{l}
    \text{each atom in C appears in F} \\
    F \models C.
  \end{array} \right.$   
\end{enumerate}

\section{Satisfiability Modulo Theories - SMT}
\subsection{Syntax} \label{subsection:smt-syntax}
\begin{definition}
A signature $\Sigma$ is a 4-tuple $(S, P, F, V, \alpha)$ containing a set $S$ of sorts, a set $P$ of predicate symbols, a set $F$ of function symbols, a set of variables, and a map $\alpha$ which associates symbols to their sorts.
\begin{itemize}
\item For all $p \in P, \, \alpha(p)$ is a $n$-tuple argument sorts of $p$.
\item For all $f \in F, \, \alpha(f)$ is a $n$-tuple of argument and returned sorts of $f$.
\item For all $v \in V, \, \alpha(v)$ represents the sort of variable $v$.
\end{itemize}
\end{definition}
A \emph{term} $t$ is defined as
\[t ::= v \mid f(t_1, \cdots, t_n)\]
where $v \in V$ is a variable, $f \in F$ is a function symbol which receives $n$ terms $t_1, \cdots, t_n$ as its arguments.

A formula $\varphi$ is defined recursively as (we only focus on quantifier-free formulas):


\subsection{Semantics}

\begin{definition}
Let $\Sigma$ is a signature. A model $M$ of $\Sigma$ is a pair $(U, I)$ in which $U$ is the universe and $I$ is the interpretation of symbols.
\begin{itemize}
\item $\forall s \in S$; $I(s) \subseteq U$ specifies the possible values of sort $s$.
\item $\forall f \in F$; $I(f) = \{(t_1,\cdots, t_n)| t_1 \in I(s_1),\cdots, t_n \in I(s_{n-1})\} \mapsto I(s_n)$ with $, \alpha(f) = (s_1,\cdots, s_n)$
\item $\forall p \in P$; $I(p) = \{(t_1,\cdots, t_n)| t_1 \in I(s_1),\cdots, t_n \in I(s_n)\} \mapsto \{0, 1\}$ with $\alpha(p) = (s_1,\cdots, s_n)$
\item $\forall v \in V$; $I(v) \in I(\alpha(v))$
\end{itemize}
\end{definition}

The interpretation of one predicate symbol is allowed to be not total and the symbol $\mathring{u}$ (unknown) is used to indicate the result of undefined operations. For further convenience, we also define the following relations: $\mathring{u} < 0, 1$ and $\mathring{u} > 0, 1$ and the following arithmetic $1 - \mathring{u} = \mathring{u}$ which are useful when we evaluate the values of logical connectives, i.e. $\wedge$, $\vee$, $\rightarrow$, $\leftrightarrow$, or $\neg$. 

\begin{definition}
Let $\Sigma$ is a signature. A $\Sigma$-theory T is a (infinite) set of $\Sigma$-models.
\end{definition}
A theory $T'$ is a subset of theory $T$ iff $T' \subseteq T$.

\begin{definition}
Let $\Sigma = (S, P, F, \alpha)$, $t$, $\varphi$ and $M=(U, I)$ are a signature, a $\Sigma-$term, a $\Sigma-$formula and a $\Sigma-$model respectively. The valuations of $t$ against $M$ which is denoted by $t^M$ is defined recursively as:
\begin{enumerate}
\item If $t = v \in V$, then $t^M = I(v)$.
\item If $t = f(t_1, \cdots, t_n)$, then $t^M = \left\{ 
  \begin{array}{c l}
    I(f)(t_1^M, \cdots, t_n^M) & \quad \text{if } (t_1^M, \cdots, t_n^M) \in Dom(I(f))\\
    \mathring{u} & \quad \text{otherwise }\\
  \end{array} \right.$ for $f \in F$ and $t_1,\cdots, t_n \in TERM$
\end{enumerate}
Similarly, the valuation $\varphi^M$ of $\varphi$ is defined as:
\begin{enumerate}
\item If $\varphi = p(t_1,\cdots,t_n)$, then $\varphi^M = \left\{ 
  \begin{array}{c l}
    I(p)(t_1^M,\cdots,t_n^M) & \quad \text{if } (t_1^M, \cdots, t_n^M) \in Dom(I(p))\\
    \mathring{u} & \quad \text{otherwise }\\
  \end{array} \right.$ for $p \in P$ and $t_1,\cdots, t_n \in TERM$
\item If $\varphi = \bot, \neg\varphi', \varphi_1 \circ \varphi_2$ for $\circ \in \{\wedge, \vee, \rightarrow, \leftrightarrow\}$ and $\varphi', \varphi_1, \varphi_2 \in FORM$, then $\varphi^M$ is defined similarly as in Definition~\ref{def:pro-val}.
\end{enumerate}
We say that $M$ satisfies $\varphi$ which is denoted by $\models_M \varphi$ iff $\varphi^M = 1$. If $\varphi^M = 0$, $\not\models_M \varphi$ is used to denote that $M$ does not satisfy $\varphi$.
\end{definition}

\begin{lemma}\label{lemma:model-sat-unsat}
Given any $\Sigma$-model $M$ and $\Sigma$-formula $\varphi$, we have $\models_M \varphi \iff \not\models_M \neg \varphi$
\end{lemma}

\begin{proof}
$\models_M \varphi \iff \varphi^M = 1 \iff 1 - \varphi^M = 0 \iff (\neg \varphi)^M = 0 \iff \not\models^M \neg \varphi$
\end{proof}

\begin{definition}
Let $T$ be a $\Sigma$-theory. A $\Sigma$-formula $\varphi$ is:
\begin{itemize}
\item satisfiable in $T$ or T-SAT iff $\exists M \in T$; $\models_{M} \varphi$
\item valid in $T$ or T-VALID iff $\forall M \in T$; $\models_{M} \varphi$
\item unsatisfiable in $T$ or T-UNSAT iff $\forall M \in T$; $\not\models_{M} \varphi$
\item unknown in $T$ or T-UNKNOWN iff $\forall M \in T$; $\varphi^M = \mathring{u}$
\end{itemize}
\end{definition}

\begin{lemma} \label{lemma:theory-valid-unsat}
If $T$ be a $\Sigma$-theory, then $\varphi$ is T-VALID $\iff$ $\neg\varphi$ is T-UNSAT
\end{lemma}

\begin{proof}
$\varphi$ is T-VALID $\iff \forall M \in T; \; \models_{M} \varphi \iff \forall M \in T; \; \not\models_{M} \neg\varphi$ (Lemma \ref{lemma:model-sat-unsat}) $\iff \neg\varphi$ is T-UNSAT.
\end{proof}

\begin{lemma} \label{lemma:subtheory-SAT}
If $T' \subseteq T$, then $\varphi$ is $T'$-SAT $\implies \varphi$ is $T$-SAT.
\end{lemma}

\begin{proof}
$\varphi$ is $T'$-SAT $\implies \exists M \in T'; \; \models_M \varphi \implies \exists M \in T; \; \models_M \varphi$ (because $T' \subseteq T$) $\implies \varphi$ is $T$-SAT.
\end{proof}

\section{Polynomial Constraints over Real Numbers}
\subsection{Syntax}
We instantiate the signature $\Sigma^p = (S^p, P^p, F^p, V^p, \alpha^p)$ in Section ~\ref{subsection:smt-syntax} for polynomial constraints as following:
\begin{enumerate}
\item $S^p = \{Real\}$
\item $P^p = \{\succ, \prec, \succeq, \preceq, \approx, \not\approx\}$
\item $F^p = \{\oplus, \ominus, \otimes, \mathbf{1}\}$
\item $\forall p \in P^p$; $\alpha^p(p) = (Real, Real)$
\item $\forall f \in F^p\setminus \{\mathbf{1}\}$; $\alpha^p(f) = (Real, Real, Real)$ and $\alpha^p(\mathbf{1})=Real$
\item $\forall v \in V; \; \alpha^P(v) = Real$
\end{enumerate}
A polynomial and a polynomial constraint are a $\Sigma^p$-term and a $\Sigma^p$-formula respectively. However, for simplicity, we currently focus on small portion of $\Sigma^p$-formulas

\begin{definition}
Given a polynomial $f$, the set of its variables which is denoted as $var(f)$ is defined recursively as following:
\begin{enumerate}
\item $var(v) = \{v\}$ for $v \in V$.
\item $var(\mathbf{1}) = \emptyset$.
\item $var(f_1 \circ f_2) = var(f_1) \cap var(f_2)$ with $\circ \in \{\oplus, \ominus, \otimes\}$.
\end{enumerate}
\end{definition}

\subsection{Semantics}
A model $M^p_{\mathbb{R}} = (\mathbb{R}, I^p_{\mathbb{R}})$ over real numbers contains the set of reals number $\mathbb{R}$ and a map $I$ that satisfies the following properties.
\begin{enumerate}
\item $I^p_{\mathbb{R}}(Real) = \mathbb{R}$.
\item $\forall p \in P^p$; $I_{\mathbb{R}}(p) = \mathbb{R} \times \mathbb{R} \mapsto \{1, 0\}$ such that $ I_\mathbb{R}^p(p)(r_1, r_2) = \left\{ 
  \begin{array}{c l}
    1 & \quad \text{if } r1 \; p_{\mathbb{R}} \; r2\\
    0 & \quad \text{otherwise }\\
  \end{array} \right.$ where $(\succ_\mathbb{R}, \prec_{\mathbb{R}},\succeq_\mathbb{R},\preceq_{\mathbb{R}}, \approx_\mathbb{R}, \not\approx_\mathbb{R}) = (>, <, \ge, \le, =, \neq)$.
\item $\forall f \in F^p \setminus \{\mathbf{1}\}$; $I^p_{\mathbb{R}}(f) = \mathbb{R} \times \mathbb{R} \mapsto \mathbb{R}$ such that $I^p_{\mathbb{R}}(f)(r_1, r_2)  = r_1 \; f_{\mathbb{R}} \; r_2$ where $(\oplus_{\mathbb{R}}, \ominus_{\mathbb{R}}, \otimes_{\mathbb{R}}) = (+, -, *)$.
\item $I^p_\mathbb{R}(\mathbf{1}) = 1$
\item $\forall v \in V$; $I^p_{\mathbb{R}}(v) \in \mathbb{R}$.
\end{enumerate}
The theory of real numbers is $T^p_{\mathbb{R}} = \{M^p_{\mathbb{R}} | M^p_{\mathbb{R}}$ is a model of real numbers $\}$.
By this instantiation, each model differs to another by the mapping from variables to real numbers. As a result, an assignment of real numbers to variables can be used to represent a model $M^p_{\mathbb{R}}$; i.e. $\{v \mapsto r \in \mathbb{R} | v \in V\}$ represents a model. Given a map $\theta = \{v \mapsto r \in \mathbb{R}| v \in V \}$, $\theta^p_\mathbb{R}$ denotes the model represented by $\theta$.

\subsubsection*{Representing (sub-)theory of real numbers as a constraint of intervals}
The signature of the first order logic is instantiated as $\Sigma^I = (S^I, P^I, F^I, \alpha^I)$ for interval constraints:
\begin{enumerate}
\item $S^I = \{Real, Interval\}$
\item $P^I = \{\in\}$
\item $F^I = \{c | c \text{ is a constant}\}$
\item $\alpha^I(\in) = (Real, Interval)$ and $\forall c \in F^I; \; \alpha^I(c) = Interval$
\item $\forall c \in F^I; \; \alpha^I(c) = Interval$.
\item $\forall v \in V; \; \alpha^I(v) = Real$.
\end{enumerate}
We call $\Sigma^I$-formula is an interval constraint.
A model $M^I_{\mathbb{R}} = (\mathbb{I} \cup \mathbb{R}, I^I)$ over intervals contains the set of real numbers and real intervals $\mathbb{I} \cup \mathbb{R}$ and a map $I^I$ that satisfies the following properties.
\begin{enumerate}
\item $I^I(Real) = \mathbb{R}$ and $I^I(Interval) = \mathbb{I}$. $\mathbb{I}$ is the set of all real intervals which is defined later in Definition~\ref{def:real_intervals}.
\item $I^I(\in) = \mathbb{R} \times \mathbb{I} \mapsto \{1, 0\}$ such that $ I_\mathbb{R}^p(p)(r, \langle a, b \rangle) = \left\{ 
  \begin{array}{c l}
    1 & \quad \text{if } a \le r \le b\\
    0 & \quad \text{otherwise }\\
  \end{array} \right.$.
\item $\forall c \in F^I$; $I^I(c) \in \mathbb{I}$.
\item $\forall v \in V$; $I^I(v) \in \mathbb{R}$.
\end{enumerate}
The theory of real intervals is $T^I = \{M^I | M^I$ is a model of real intervals $\}$.
By this instantiation, each model differs to another by the mapping from variables to real numbers. As a result, an assignment of real numbers to variables can be used to represent a model $M^I$; i.e. $\{v \mapsto r \in \mathbb{R} | v \in V\}$ represents a model. Given a map $\theta = \{v \mapsto r \in \mathbb{R} | v \in V\}$, we denote $\theta^I$ as a model of real intervals. If $\Pi$ is an interval constraint, the notation $\Pi^p_\mathbb{R} = \{\theta^p_\mathbb{R} | \theta = \{v \mapsto r \in \mathbb{R} | v \in V\} \text{ and } \models_{\theta^I} \Pi \}$ represents the (sub-)theory of real numbers that each of its model (after converted into the model of intervals) satisfies the constraint $\Pi$.



% % % % % % % % % % % 